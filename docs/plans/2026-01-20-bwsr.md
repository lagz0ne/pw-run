# bwsr Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a fast, precompiled CLI for managing browser daemons that exposes CDP endpoints for tools like agent-browser.

**Architecture:** Three-layer design - CLI communicates with Watchdog via IPC, Watchdog polls Wrappers via IPC, each Wrapper holds a Playwright browser instance. Socket-based discovery enables watchdog recovery. Single binary compiled via `bun build --compile`.

**Tech Stack:** Bun, TypeScript, Playwright, Unix sockets (IPC), YAML (profiles)

---

## Task 1: Project Setup

**Files:**
- Modify: `package.json`
- Create: `tsconfig.json`
- Create: `src/index.ts`

**Step 1: Update package.json**

```json
{
  "name": "bwsr",
  "version": "0.1.0",
  "module": "src/index.ts",
  "type": "module",
  "bin": {
    "bwsr": "./dist/bwsr"
  },
  "scripts": {
    "build": "bun build --compile --minify src/index.ts --outfile dist/bwsr",
    "dev": "bun run src/index.ts",
    "test": "bun test"
  },
  "devDependencies": {
    "@types/bun": "latest"
  },
  "dependencies": {
    "playwright-core": "^1.57.0",
    "yaml": "^2.3.4"
  }
}
```

**Step 2: Create tsconfig.json**

```json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "skipLibCheck": true,
    "noEmit": true,
    "types": ["bun-types"]
  },
  "include": ["src/**/*", "tests/**/*"]
}
```

**Step 3: Create entry point stub**

```typescript
// src/index.ts
console.log("bwsr");
```

**Step 4: Install dependencies**

Run: `bun install`

**Step 5: Verify setup**

Run: `bun run dev`
Expected: Outputs "bwsr"

**Step 6: Commit**

```bash
git init
git add -A
git commit -m "chore: initial project setup"
```

---

## Task 2: Session Name Generator

**Files:**
- Create: `src/utils/names.ts`
- Create: `tests/utils/names.test.ts`

**Step 1: Write the failing test**

```typescript
// tests/utils/names.test.ts
import { describe, test, expect } from "bun:test";
import { generateSessionName, isValidSessionName } from "../src/utils/names";

describe("generateSessionName", () => {
  test("returns adjective-noun format", () => {
    const name = generateSessionName();
    expect(name).toMatch(/^[a-z]+-[a-z]+$/);
  });

  test("generates unique names", () => {
    const names = new Set(Array.from({ length: 100 }, () => generateSessionName()));
    expect(names.size).toBeGreaterThan(90);
  });
});

describe("isValidSessionName", () => {
  test("accepts valid names", () => {
    expect(isValidSessionName("happy-fox")).toBe(true);
    expect(isValidSessionName("my-session")).toBe(true);
    expect(isValidSessionName("test123")).toBe(true);
  });

  test("rejects invalid names", () => {
    expect(isValidSessionName("")).toBe(false);
    expect(isValidSessionName("has spaces")).toBe(false);
    expect(isValidSessionName("has/slash")).toBe(false);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `bun test tests/utils/names.test.ts`
Expected: FAIL with "cannot find module"

**Step 3: Write implementation**

```typescript
// src/utils/names.ts
const adjectives = [
  "happy", "calm", "swift", "bright", "quiet", "bold", "keen", "warm",
  "cool", "fair", "kind", "wise", "brave", "quick", "sharp", "clear",
  "fresh", "light", "soft", "pure", "neat", "prime", "true", "fine"
];

const nouns = [
  "fox", "bear", "owl", "wolf", "deer", "hawk", "lynx", "crow",
  "dove", "hare", "seal", "wren", "moth", "swan", "toad", "wasp",
  "crab", "goat", "lamb", "newt", "puma", "ram", "yak", "elk"
];

export function generateSessionName(): string {
  const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
  const noun = nouns[Math.floor(Math.random() * nouns.length)];
  return `${adj}-${noun}`;
}

export function isValidSessionName(name: string): boolean {
  if (!name || name.length === 0) return false;
  return /^[a-z0-9][a-z0-9-]*[a-z0-9]$|^[a-z0-9]$/.test(name);
}
```

**Step 4: Run test to verify it passes**

Run: `bun test tests/utils/names.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/utils/names.ts tests/utils/names.test.ts
git commit -m "feat: add session name generator"
```

---

## Task 3: Paths and Directory Structure

**Files:**
- Create: `src/utils/paths.ts`
- Create: `tests/utils/paths.test.ts`

**Step 1: Write the failing test**

```typescript
// tests/utils/paths.test.ts
import { describe, test, expect } from "bun:test";
import { getPaths } from "../src/utils/paths";

describe("getPaths", () => {
  test("returns expected directory structure", () => {
    const paths = getPaths();

    expect(paths.root).toContain(".bwsr");
    expect(paths.profiles).toContain("profiles");
    expect(paths.sockets).toContain("sockets");
    expect(paths.watchdogSocket).toContain("watchdog.sock");
  });

  test("profile path includes name", () => {
    const paths = getPaths();
    expect(paths.profile("default")).toContain("default.yaml");
  });

  test("session socket path includes name", () => {
    const paths = getPaths();
    expect(paths.sessionSocket("happy-fox")).toContain("happy-fox.sock");
  });
});
```

**Step 2: Run test to verify it fails**

Run: `bun test tests/utils/paths.test.ts`
Expected: FAIL

**Step 3: Write implementation**

```typescript
// src/utils/paths.ts
import { homedir } from "os";
import { join } from "path";

export interface BwsrPaths {
  root: string;
  profiles: string;
  sockets: string;
  watchdogSocket: string;
  profile: (name: string) => string;
  sessionSocket: (session: string) => string;
}

export function getPaths(): BwsrPaths {
  const root = join(homedir(), ".bwsr");
  const profiles = join(root, "profiles");
  const sockets = join(root, "sockets");

  return {
    root,
    profiles,
    sockets,
    watchdogSocket: join(sockets, "watchdog.sock"),
    profile: (name: string) => join(profiles, `${name}.yaml`),
    sessionSocket: (session: string) => join(sockets, `${session}.sock`),
  };
}

export async function ensureDirectories(): Promise<void> {
  const paths = getPaths();
  await Bun.write(paths.profiles + "/.keep", "");
  await Bun.write(paths.sockets + "/.keep", "");
}
```

**Step 4: Run test to verify it passes**

Run: `bun test tests/utils/paths.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/utils/paths.ts tests/utils/paths.test.ts
git commit -m "feat: add paths utility"
```

---

## Task 4: Profile Schema and Management

**Files:**
- Create: `src/profile/schema.ts`
- Create: `src/profile/manager.ts`
- Create: `tests/profile/manager.test.ts`

**Step 1: Write profile schema**

```typescript
// src/profile/schema.ts
export interface Viewport {
  width: number;
  height: number;
}

export interface Profile {
  browser?: "chromium" | "firefox" | "webkit";
  executable?: string;
  headless?: boolean;
  viewport?: Viewport;
  args?: string[];
  locale?: string;
  timezone?: string;
  colorScheme?: "light" | "dark" | "no-preference";
  userAgent?: string;
  proxy?: string;
  ignoreHTTPSErrors?: boolean;
  offline?: boolean;
}

export const defaultProfile: Profile = {
  browser: "chromium",
  headless: true,
};
```

**Step 2: Write the failing test for manager**

```typescript
// tests/profile/manager.test.ts
import { describe, test, expect, beforeEach, afterEach } from "bun:test";
import { ProfileManager } from "../src/profile/manager";
import { rmSync, mkdirSync } from "fs";
import { join } from "path";
import { tmpdir } from "os";

describe("ProfileManager", () => {
  let testDir: string;
  let manager: ProfileManager;

  beforeEach(() => {
    testDir = join(tmpdir(), `bwsr-test-${Date.now()}`);
    mkdirSync(testDir, { recursive: true });
    manager = new ProfileManager(testDir);
  });

  afterEach(() => {
    rmSync(testDir, { recursive: true, force: true });
  });

  test("create and get profile", async () => {
    await manager.create("test", { browser: "chromium", headless: true });
    const profile = await manager.get("test");
    expect(profile?.browser).toBe("chromium");
    expect(profile?.headless).toBe(true);
  });

  test("list profiles", async () => {
    await manager.create("one", { browser: "chromium" });
    await manager.create("two", { browser: "firefox" });
    const list = await manager.list();
    expect(list).toContain("one");
    expect(list).toContain("two");
  });

  test("set updates profile", async () => {
    await manager.create("test", { headless: true });
    await manager.set("test", { headless: false, locale: "en-US" });
    const profile = await manager.get("test");
    expect(profile?.headless).toBe(false);
    expect(profile?.locale).toBe("en-US");
  });

  test("remove deletes profile", async () => {
    await manager.create("test", { browser: "chromium" });
    await manager.remove("test");
    const profile = await manager.get("test");
    expect(profile).toBeNull();
  });

  test("get returns null for missing profile", async () => {
    const profile = await manager.get("nonexistent");
    expect(profile).toBeNull();
  });
});
```

**Step 3: Run test to verify it fails**

Run: `bun test tests/profile/manager.test.ts`
Expected: FAIL

**Step 4: Write implementation**

```typescript
// src/profile/manager.ts
import { parse, stringify } from "yaml";
import { join } from "path";
import type { Profile } from "./schema";

export class ProfileManager {
  constructor(private profilesDir: string) {}

  async create(name: string, profile: Profile): Promise<void> {
    const path = this.path(name);
    await Bun.write(path, stringify(profile));
  }

  async get(name: string): Promise<Profile | null> {
    const path = this.path(name);
    const file = Bun.file(path);
    if (!(await file.exists())) return null;
    const content = await file.text();
    return parse(content) as Profile;
  }

  async set(name: string, updates: Partial<Profile>): Promise<void> {
    const existing = await this.get(name);
    if (!existing) throw new Error(`Profile '${name}' not found`);
    const merged = { ...existing, ...updates };
    await Bun.write(this.path(name), stringify(merged));
  }

  async append(name: string, key: "args", values: string[]): Promise<void> {
    const existing = await this.get(name);
    if (!existing) throw new Error(`Profile '${name}' not found`);
    const current = existing[key] || [];
    existing[key] = [...current, ...values];
    await Bun.write(this.path(name), stringify(existing));
  }

  async unset(name: string, keys: (keyof Profile)[]): Promise<void> {
    const existing = await this.get(name);
    if (!existing) throw new Error(`Profile '${name}' not found`);
    for (const key of keys) {
      delete existing[key];
    }
    await Bun.write(this.path(name), stringify(existing));
  }

  async remove(name: string): Promise<void> {
    const path = this.path(name);
    const file = Bun.file(path);
    if (await file.exists()) {
      await Bun.write(path, ""); // Clear then unlink
      const { unlink } = await import("fs/promises");
      await unlink(path);
    }
  }

  async list(): Promise<string[]> {
    const { readdir } = await import("fs/promises");
    try {
      const files = await readdir(this.profilesDir);
      return files
        .filter((f) => f.endsWith(".yaml"))
        .map((f) => f.replace(".yaml", ""));
    } catch {
      return [];
    }
  }

  private path(name: string): string {
    return join(this.profilesDir, `${name}.yaml`);
  }
}
```

**Step 5: Run test to verify it passes**

Run: `bun test tests/profile/manager.test.ts`
Expected: PASS

**Step 6: Commit**

```bash
git add src/profile/schema.ts src/profile/manager.ts tests/profile/manager.test.ts
git commit -m "feat: add profile management"
```

---

## Task 5: Browser Discovery

**Files:**
- Create: `src/browser/discovery.ts`
- Create: `tests/browser/discovery.test.ts`

**Step 1: Write the failing test**

```typescript
// tests/browser/discovery.test.ts
import { describe, test, expect } from "bun:test";
import { discoverBrowser } from "../src/browser/discovery";

describe("discoverBrowser", () => {
  test("finds playwright browsers in cache", async () => {
    // This test may pass or fail depending on installed browsers
    // It mainly tests the discovery logic doesn't throw
    const result = await discoverBrowser("chromium");
    // Result is either a path string or null
    expect(result === null || typeof result === "string").toBe(true);
  });

  test("returns null for unknown browser type", async () => {
    const result = await discoverBrowser("unknown" as any);
    expect(result).toBeNull();
  });
});
```

**Step 2: Run test to verify it fails**

Run: `bun test tests/browser/discovery.test.ts`
Expected: FAIL

**Step 3: Write implementation**

```typescript
// src/browser/discovery.ts
import { homedir } from "os";
import { join } from "path";
import { readdir, stat } from "fs/promises";

type BrowserType = "chromium" | "firefox" | "webkit";

interface BrowserPaths {
  chromium: string[];
  firefox: string[];
  webkit: string[];
}

const playwrightCache = join(homedir(), ".cache", "ms-playwright");

const systemPaths: BrowserPaths = {
  chromium: [
    "/usr/bin/chromium",
    "/usr/bin/chromium-browser",
    "/usr/bin/google-chrome",
    "/usr/bin/google-chrome-stable",
    "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
    "/Applications/Chromium.app/Contents/MacOS/Chromium",
  ],
  firefox: [
    "/usr/bin/firefox",
    "/Applications/Firefox.app/Contents/MacOS/firefox",
  ],
  webkit: [], // WebKit typically only via Playwright
};

const playwrightExecutables: Record<BrowserType, string> = {
  chromium: process.platform === "darwin"
    ? "chrome-mac/Chromium.app/Contents/MacOS/Chromium"
    : "chrome-linux/chrome",
  firefox: process.platform === "darwin"
    ? "firefox/Nightly.app/Contents/MacOS/firefox"
    : "firefox/firefox",
  webkit: process.platform === "darwin"
    ? "pw_run.app/Contents/MacOS/pw_run"
    : "playwright-webkit/pw_run.sh",
};

async function exists(path: string): Promise<boolean> {
  try {
    await stat(path);
    return true;
  } catch {
    return false;
  }
}

async function findLatestPlaywrightBrowser(browser: BrowserType): Promise<string | null> {
  try {
    const entries = await readdir(playwrightCache);
    const matching = entries
      .filter((e) => e.startsWith(browser + "-"))
      .sort()
      .reverse(); // Latest version first

    for (const dir of matching) {
      const execPath = join(playwrightCache, dir, playwrightExecutables[browser]);
      if (await exists(execPath)) {
        return execPath;
      }
    }
  } catch {
    // Cache dir doesn't exist
  }
  return null;
}

async function findSystemBrowser(browser: BrowserType): Promise<string | null> {
  for (const path of systemPaths[browser]) {
    if (await exists(path)) {
      return path;
    }
  }
  return null;
}

export async function discoverBrowser(browser: BrowserType): Promise<string | null> {
  if (!["chromium", "firefox", "webkit"].includes(browser)) {
    return null;
  }

  // Check PLAYWRIGHT_BROWSERS_PATH first
  const customPath = process.env.PLAYWRIGHT_BROWSERS_PATH;
  if (customPath) {
    const execPath = join(customPath, `${browser}-*`, playwrightExecutables[browser]);
    // Would need glob here, simplified for now
  }

  // Try Playwright cache (preferred - known good version)
  const playwrightPath = await findLatestPlaywrightBrowser(browser);
  if (playwrightPath) return playwrightPath;

  // Fall back to system browser
  const systemPath = await findSystemBrowser(browser);
  if (systemPath) return systemPath;

  return null;
}
```

**Step 4: Run test to verify it passes**

Run: `bun test tests/browser/discovery.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/browser/discovery.ts tests/browser/discovery.test.ts
git commit -m "feat: add browser discovery"
```

---

## Task 6: IPC Protocol Types

**Files:**
- Create: `src/ipc/protocol.ts`

**Step 1: Write protocol types**

```typescript
// src/ipc/protocol.ts

// CLI → Watchdog messages
export type WatchdogRequest =
  | { type: "start"; profile: string; session: string }
  | { type: "stop"; session: string }
  | { type: "stopAll" }
  | { type: "list" }
  | { type: "cdp"; session?: string };

// Watchdog → CLI responses
export type WatchdogResponse =
  | { ok: true; session: string; cdpPort: number }
  | { ok: true; instances: InstanceInfo[] }
  | { ok: true; cdpPort: number }
  | { ok: true }
  | { ok: false; error: string };

// Watchdog ↔ Wrapper messages
export type WrapperRequest =
  | { type: "ping" }
  | { type: "shutdown" };

export type WrapperResponse =
  | { type: "pong"; cdpPort: number; status: "healthy" | "unhealthy"; lastUsed: string }
  | { type: "shutdownAck" };

// Instance info for list command
export interface InstanceInfo {
  session: string;
  profile: string;
  cdpPort: number;
  lastUsed: string;
  lastPulse: string;
  status: "healthy" | "unhealthy";
}

// Serialize/deserialize helpers
export function encode(msg: unknown): Buffer {
  return Buffer.from(JSON.stringify(msg) + "\n");
}

export function decode<T>(data: Buffer): T {
  return JSON.parse(data.toString().trim());
}
```

**Step 2: Commit**

```bash
git add src/ipc/protocol.ts
git commit -m "feat: add IPC protocol types"
```

---

## Task 7: Wrapper Implementation

**Files:**
- Create: `src/wrapper/index.ts`
- Create: `tests/wrapper/wrapper.test.ts`

**Step 1: Write the failing test**

```typescript
// tests/wrapper/wrapper.test.ts
import { describe, test, expect } from "bun:test";
import { Wrapper } from "../src/wrapper";
import type { Profile } from "../src/profile/schema";

describe("Wrapper", () => {
  test("can be instantiated with profile", () => {
    const profile: Profile = { browser: "chromium", headless: true };
    const wrapper = new Wrapper("test-session", profile);
    expect(wrapper.session).toBe("test-session");
  });
});
```

**Step 2: Run test to verify it fails**

Run: `bun test tests/wrapper/wrapper.test.ts`
Expected: FAIL

**Step 3: Write implementation**

```typescript
// src/wrapper/index.ts
import { chromium, firefox, webkit, type Browser, type BrowserContext } from "playwright-core";
import { createServer, type Server } from "net";
import { unlinkSync } from "fs";
import type { Profile } from "../profile/schema";
import type { WrapperRequest, WrapperResponse } from "../ipc/protocol";
import { encode, decode } from "../ipc/protocol";
import { getPaths } from "../utils/paths";
import { discoverBrowser } from "../browser/discovery";

export class Wrapper {
  public readonly session: string;
  private profile: Profile;
  private browser: Browser | null = null;
  private context: BrowserContext | null = null;
  private cdpPort: number = 0;
  private server: Server | null = null;
  private lastUsed: Date = new Date();

  constructor(session: string, profile: Profile) {
    this.session = session;
    this.profile = profile;
  }

  async start(): Promise<number> {
    const browserType = this.profile.browser || "chromium";
    const launcher = { chromium, firefox, webkit }[browserType];

    if (!launcher) {
      throw new Error(`Unknown browser type: ${browserType}`);
    }

    const executablePath = this.profile.executable || await discoverBrowser(browserType);
    if (!executablePath) {
      throw new Error(`Could not find ${browserType} browser. Install via: npx playwright install ${browserType}`);
    }

    // Launch with random CDP port
    this.browser = await launcher.launch({
      headless: this.profile.headless ?? true,
      executablePath,
      args: [
        ...(this.profile.args || []),
        "--remote-debugging-port=0", // Random port
      ],
    });

    // Get actual CDP port from browser
    // The CDP endpoint URL contains the port
    const cdpUrl = this.browser.contexts()[0]?.pages()[0]?.url() || "";
    // Actually we need to get it differently - from the browser process

    // Create a new context with profile settings
    this.context = await this.browser.newContext({
      viewport: this.profile.viewport,
      locale: this.profile.locale,
      timezoneId: this.profile.timezone,
      colorScheme: this.profile.colorScheme,
      userAgent: this.profile.userAgent,
      ignoreHTTPSErrors: this.profile.ignoreHTTPSErrors,
      offline: this.profile.offline,
    });

    // Get CDP WebSocket endpoint and extract port
    const wsEndpoint = this.browser.wsEndpoint?.() || "";
    const match = wsEndpoint.match(/:(\d+)\//);
    this.cdpPort = match ? parseInt(match[1], 10) : 0;

    // Start IPC server
    await this.startIpcServer();

    return this.cdpPort;
  }

  private async startIpcServer(): Promise<void> {
    const socketPath = getPaths().sessionSocket(this.session);

    // Clean up stale socket
    try { unlinkSync(socketPath); } catch {}

    this.server = createServer((socket) => {
      socket.on("data", async (data) => {
        try {
          const req = decode<WrapperRequest>(data);
          const res = await this.handleRequest(req);
          socket.write(encode(res));
        } catch (err) {
          socket.write(encode({ type: "error", message: String(err) }));
        }
      });
    });

    return new Promise((resolve) => {
      this.server!.listen(socketPath, () => resolve());
    });
  }

  private async handleRequest(req: WrapperRequest): Promise<WrapperResponse> {
    switch (req.type) {
      case "ping":
        this.lastUsed = new Date();
        return {
          type: "pong",
          cdpPort: this.cdpPort,
          status: this.browser?.isConnected() ? "healthy" : "unhealthy",
          lastUsed: this.lastUsed.toISOString(),
        };

      case "shutdown":
        await this.stop();
        return { type: "shutdownAck" };

      default:
        throw new Error(`Unknown request type`);
    }
  }

  async stop(): Promise<void> {
    if (this.context) {
      await this.context.close();
      this.context = null;
    }
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
    if (this.server) {
      this.server.close();
      const socketPath = getPaths().sessionSocket(this.session);
      try { unlinkSync(socketPath); } catch {}
    }
  }

  isHealthy(): boolean {
    return this.browser?.isConnected() ?? false;
  }
}
```

**Step 4: Run test to verify it passes**

Run: `bun test tests/wrapper/wrapper.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/wrapper/index.ts tests/wrapper/wrapper.test.ts
git commit -m "feat: add wrapper implementation"
```

---

## Task 8: Watchdog Implementation

**Files:**
- Create: `src/watchdog/index.ts`

**Step 1: Write implementation**

```typescript
// src/watchdog/index.ts
import { createServer, createConnection, type Server, type Socket } from "net";
import { unlinkSync, readdirSync } from "fs";
import { getPaths } from "../utils/paths";
import { ProfileManager } from "../profile/manager";
import { Wrapper } from "../wrapper";
import { generateSessionName } from "../utils/names";
import type { WatchdogRequest, WatchdogResponse, InstanceInfo, WrapperResponse } from "../ipc/protocol";
import { encode, decode } from "../ipc/protocol";

export class Watchdog {
  private server: Server | null = null;
  private wrappers: Map<string, Wrapper> = new Map();
  private profileManager: ProfileManager;
  private pollInterval: NodeJS.Timeout | null = null;

  constructor() {
    const paths = getPaths();
    this.profileManager = new ProfileManager(paths.profiles);
  }

  async start(): Promise<void> {
    const paths = getPaths();

    // Clean up stale socket
    try { unlinkSync(paths.watchdogSocket); } catch {}

    // Discover existing wrappers
    await this.discoverExistingWrappers();

    // Start IPC server
    this.server = createServer((socket) => {
      this.handleConnection(socket);
    });

    await new Promise<void>((resolve) => {
      this.server!.listen(paths.watchdogSocket, () => resolve());
    });

    // Start polling wrappers
    this.startPolling();
  }

  private async discoverExistingWrappers(): Promise<void> {
    const paths = getPaths();
    try {
      const files = readdirSync(paths.sockets);
      for (const file of files) {
        if (file === "watchdog.sock" || !file.endsWith(".sock")) continue;
        const session = file.replace(".sock", "");
        const socketPath = paths.sessionSocket(session);

        // Try to ping it
        try {
          const response = await this.pingWrapper(socketPath);
          if (response) {
            // Wrapper is alive - we don't have the Wrapper object,
            // but we track it exists for cleanup purposes
            console.error(`Recovered session: ${session}`);
          }
        } catch {
          // Dead socket, clean up
          try { unlinkSync(socketPath); } catch {}
        }
      }
    } catch {
      // Sockets dir doesn't exist yet
    }
  }

  private async pingWrapper(socketPath: string): Promise<WrapperResponse | null> {
    return new Promise((resolve) => {
      const socket = createConnection(socketPath);
      const timeout = setTimeout(() => {
        socket.destroy();
        resolve(null);
      }, 1000);

      socket.on("connect", () => {
        socket.write(encode({ type: "ping" }));
      });

      socket.on("data", (data) => {
        clearTimeout(timeout);
        socket.end();
        resolve(decode<WrapperResponse>(data));
      });

      socket.on("error", () => {
        clearTimeout(timeout);
        resolve(null);
      });
    });
  }

  private startPolling(): void {
    this.pollInterval = setInterval(() => this.pollWrappers(), 5000);
  }

  private async pollWrappers(): Promise<void> {
    const paths = getPaths();

    for (const [session, wrapper] of this.wrappers) {
      if (!wrapper.isHealthy()) {
        console.error(`Session ${session} unhealthy, removing`);
        this.wrappers.delete(session);
        try { unlinkSync(paths.sessionSocket(session)); } catch {}
      }
    }

    // Check if we should exit (no wrappers left)
    if (this.wrappers.size === 0) {
      // Give a grace period before exiting
      setTimeout(() => {
        if (this.wrappers.size === 0) {
          this.stop();
          process.exit(0);
        }
      }, 5000);
    }
  }

  private handleConnection(socket: Socket): void {
    socket.on("data", async (data) => {
      try {
        const req = decode<WatchdogRequest>(data);
        const res = await this.handleRequest(req);
        socket.write(encode(res));
      } catch (err) {
        socket.write(encode({ ok: false, error: String(err) }));
      }
    });
  }

  private async handleRequest(req: WatchdogRequest): Promise<WatchdogResponse> {
    switch (req.type) {
      case "start":
        return this.handleStart(req.profile, req.session);

      case "stop":
        return this.handleStop(req.session);

      case "stopAll":
        return this.handleStopAll();

      case "list":
        return this.handleList();

      case "cdp":
        return this.handleCdp(req.session);

      default:
        return { ok: false, error: "Unknown request type" };
    }
  }

  private async handleStart(profileName: string, sessionName: string): Promise<WatchdogResponse> {
    const profile = await this.profileManager.get(profileName);
    if (!profile) {
      return { ok: false, error: `Profile '${profileName}' not found` };
    }

    const session = sessionName || generateSessionName();

    if (this.wrappers.has(session)) {
      return { ok: false, error: `Session '${session}' already exists` };
    }

    const wrapper = new Wrapper(session, profile);

    try {
      const cdpPort = await wrapper.start();
      this.wrappers.set(session, wrapper);
      return { ok: true, session, cdpPort };
    } catch (err) {
      return { ok: false, error: String(err) };
    }
  }

  private async handleStop(session: string): Promise<WatchdogResponse> {
    const wrapper = this.wrappers.get(session);
    if (!wrapper) {
      return { ok: false, error: `Session '${session}' not found` };
    }

    await wrapper.stop();
    this.wrappers.delete(session);
    return { ok: true };
  }

  private async handleStopAll(): Promise<WatchdogResponse> {
    for (const [session, wrapper] of this.wrappers) {
      await wrapper.stop();
      this.wrappers.delete(session);
    }
    return { ok: true };
  }

  private async handleList(): Promise<WatchdogResponse> {
    const instances: InstanceInfo[] = [];
    const paths = getPaths();

    for (const [session, wrapper] of this.wrappers) {
      const socketPath = paths.sessionSocket(session);
      const response = await this.pingWrapper(socketPath);

      if (response && response.type === "pong") {
        instances.push({
          session,
          profile: "default", // TODO: track profile name
          cdpPort: response.cdpPort,
          lastUsed: response.lastUsed,
          lastPulse: new Date().toISOString(),
          status: response.status,
        });
      }
    }

    return { ok: true, instances };
  }

  private async handleCdp(session?: string): Promise<WatchdogResponse> {
    // If no session specified, use first available
    const targetSession = session || this.wrappers.keys().next().value;

    if (!targetSession) {
      return { ok: false, error: "No running sessions" };
    }

    const paths = getPaths();
    const socketPath = paths.sessionSocket(targetSession);
    const response = await this.pingWrapper(socketPath);

    if (response && response.type === "pong") {
      return { ok: true, cdpPort: response.cdpPort };
    }

    return { ok: false, error: `Session '${targetSession}' not responding` };
  }

  async stop(): Promise<void> {
    if (this.pollInterval) {
      clearInterval(this.pollInterval);
    }

    for (const [, wrapper] of this.wrappers) {
      await wrapper.stop();
    }

    if (this.server) {
      this.server.close();
      const paths = getPaths();
      try { unlinkSync(paths.watchdogSocket); } catch {}
    }
  }
}

// Entry point for watchdog mode
export async function runWatchdog(): Promise<void> {
  const watchdog = new Watchdog();

  process.on("SIGINT", async () => {
    await watchdog.stop();
    process.exit(0);
  });

  process.on("SIGTERM", async () => {
    await watchdog.stop();
    process.exit(0);
  });

  await watchdog.start();
}
```

**Step 2: Commit**

```bash
git add src/watchdog/index.ts
git commit -m "feat: add watchdog implementation"
```

---

## Task 9: CLI Client

**Files:**
- Create: `src/cli/client.ts`

**Step 1: Write implementation**

```typescript
// src/cli/client.ts
import { createConnection } from "net";
import { spawn } from "child_process";
import { existsSync } from "fs";
import { getPaths } from "../utils/paths";
import type { WatchdogRequest, WatchdogResponse } from "../ipc/protocol";
import { encode, decode } from "../ipc/protocol";

export class Client {
  private async ensureWatchdog(): Promise<void> {
    const paths = getPaths();

    if (existsSync(paths.watchdogSocket)) {
      // Try to ping it
      try {
        await this.send({ type: "list" });
        return; // Watchdog is running
      } catch {
        // Socket exists but watchdog is dead
      }
    }

    // Start watchdog
    const proc = spawn(process.execPath, [process.argv[1], "--watchdog"], {
      detached: true,
      stdio: "ignore",
    });
    proc.unref();

    // Wait for watchdog to be ready
    for (let i = 0; i < 50; i++) {
      await new Promise((r) => setTimeout(r, 100));
      try {
        await this.send({ type: "list" });
        return;
      } catch {
        // Not ready yet
      }
    }

    throw new Error("Failed to start watchdog");
  }

  private send(req: WatchdogRequest): Promise<WatchdogResponse> {
    return new Promise((resolve, reject) => {
      const paths = getPaths();
      const socket = createConnection(paths.watchdogSocket);

      const timeout = setTimeout(() => {
        socket.destroy();
        reject(new Error("Request timeout"));
      }, 10000);

      socket.on("connect", () => {
        socket.write(encode(req));
      });

      socket.on("data", (data) => {
        clearTimeout(timeout);
        socket.end();
        resolve(decode<WatchdogResponse>(data));
      });

      socket.on("error", (err) => {
        clearTimeout(timeout);
        reject(err);
      });
    });
  }

  async start(profile: string, session: string): Promise<WatchdogResponse> {
    await this.ensureWatchdog();
    return this.send({ type: "start", profile, session });
  }

  async stop(session: string): Promise<WatchdogResponse> {
    return this.send({ type: "stop", session });
  }

  async stopAll(): Promise<WatchdogResponse> {
    return this.send({ type: "stopAll" });
  }

  async list(): Promise<WatchdogResponse> {
    try {
      return await this.send({ type: "list" });
    } catch {
      // No watchdog running = no instances
      return { ok: true, instances: [] };
    }
  }

  async cdp(session?: string): Promise<WatchdogResponse> {
    return this.send({ type: "cdp", session });
  }
}
```

**Step 2: Commit**

```bash
git add src/cli/client.ts
git commit -m "feat: add CLI client"
```

---

## Task 10: CLI Commands

**Files:**
- Create: `src/cli/commands.ts`
- Modify: `src/index.ts`

**Step 1: Write commands implementation**

```typescript
// src/cli/commands.ts
import { Client } from "./client";
import { ProfileManager } from "../profile/manager";
import { getPaths, ensureDirectories } from "../utils/paths";
import type { Profile } from "../profile/schema";

const client = new Client();

export async function cmdStart(options: {
  profile?: string;
  session?: string;
  verbose?: boolean;
}): Promise<void> {
  await ensureDirectories();

  const profile = options.profile || "default";
  const session = options.session || "";

  const res = await client.start(profile, session);

  if (!res.ok) {
    console.error(res.error);
    process.exit(1);
  }

  if (options.verbose && "session" in res) {
    console.log(`Session: ${res.session}`);
    console.log(`CDP: ${res.cdpPort}`);
    console.log(`Profile: ${profile}`);
  } else if ("session" in res) {
    console.log(res.session);
  }
}

export async function cmdStop(session: string): Promise<void> {
  const res = await client.stop(session);
  if (!res.ok) {
    console.error(res.error);
    process.exit(1);
  }
}

export async function cmdStopAll(): Promise<void> {
  const res = await client.stopAll();
  if (!res.ok) {
    console.error(res.error);
    process.exit(1);
  }
}

export async function cmdList(): Promise<void> {
  const res = await client.list();

  if (!res.ok) {
    console.error(res.error);
    process.exit(1);
  }

  if ("instances" in res && res.instances.length === 0) {
    return; // Silent when no instances
  }

  if ("instances" in res) {
    for (const inst of res.instances) {
      console.log(`${inst.session}\t${inst.profile}\t${inst.cdpPort}\t${inst.status}`);
    }
  }
}

export async function cmdCdp(session?: string): Promise<void> {
  const res = await client.cdp(session);

  if (!res.ok) {
    console.error(res.error);
    process.exit(1);
  }

  if ("cdpPort" in res) {
    console.log(res.cdpPort);
  }
}

export async function cmdProfileCreate(name: string): Promise<void> {
  await ensureDirectories();
  const paths = getPaths();
  const manager = new ProfileManager(paths.profiles);

  const existing = await manager.get(name);
  if (existing) {
    console.error(`Profile '${name}' already exists`);
    process.exit(1);
  }

  await manager.create(name, { browser: "chromium", headless: true });
}

export async function cmdProfileSet(name: string, updates: Partial<Profile>): Promise<void> {
  const paths = getPaths();
  const manager = new ProfileManager(paths.profiles);

  try {
    await manager.set(name, updates);
  } catch (err) {
    console.error(String(err));
    process.exit(1);
  }
}

export async function cmdProfileRemove(name: string): Promise<void> {
  const paths = getPaths();
  const manager = new ProfileManager(paths.profiles);
  await manager.remove(name);
}

export async function cmdProfileList(): Promise<void> {
  const paths = getPaths();
  const manager = new ProfileManager(paths.profiles);
  const profiles = await manager.list();

  for (const p of profiles) {
    console.log(p);
  }
}

export async function cmdProfileShow(name: string): Promise<void> {
  const paths = getPaths();
  const manager = new ProfileManager(paths.profiles);
  const profile = await manager.get(name);

  if (!profile) {
    console.error(`Profile '${name}' not found`);
    process.exit(1);
  }

  const { stringify } = await import("yaml");
  console.log(stringify(profile));
}

export async function cmdDoctor(): Promise<void> {
  const paths = getPaths();

  console.log("Checking bwsr installation...\n");

  console.log(`Config dir: ${paths.root}`);
  console.log(`Profiles: ${paths.profiles}`);
  console.log(`Sockets: ${paths.sockets}`);

  // Check for browsers
  const { discoverBrowser } = await import("../browser/discovery");

  console.log("\nBrowsers:");
  for (const browser of ["chromium", "firefox", "webkit"] as const) {
    const path = await discoverBrowser(browser);
    console.log(`  ${browser}: ${path || "not found"}`);
  }

  // Check running instances
  const res = await client.list();
  if ("instances" in res) {
    console.log(`\nRunning instances: ${res.instances.length}`);
  }
}
```

**Step 2: Write main entry point**

```typescript
// src/index.ts
import { runWatchdog } from "./watchdog";
import {
  cmdStart,
  cmdStop,
  cmdStopAll,
  cmdList,
  cmdCdp,
  cmdProfileCreate,
  cmdProfileSet,
  cmdProfileRemove,
  cmdProfileList,
  cmdProfileShow,
  cmdDoctor,
} from "./cli/commands";

const args = process.argv.slice(2);

function parseFlags(args: string[]): Record<string, string | boolean> {
  const flags: Record<string, string | boolean> = {};
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.startsWith("--")) {
      const key = arg.slice(2);
      const next = args[i + 1];
      if (next && !next.startsWith("--")) {
        flags[key] = next;
        i++;
      } else {
        flags[key] = true;
      }
    }
  }
  return flags;
}

async function main(): Promise<void> {
  const command = args[0];
  const flags = parseFlags(args);

  // Watchdog mode (internal)
  if (flags.watchdog) {
    await runWatchdog();
    return;
  }

  switch (command) {
    case "start":
      await cmdStart({
        profile: flags.profile as string | undefined,
        session: flags.session as string | undefined,
        verbose: Boolean(flags.verbose),
      });
      break;

    case "stop":
      if (flags.all) {
        await cmdStopAll();
      } else {
        const session = args[1];
        if (!session) {
          console.error("Usage: bwsr stop <session> | --all");
          process.exit(1);
        }
        await cmdStop(session);
      }
      break;

    case "list":
      await cmdList();
      break;

    case "cdp":
      await cmdCdp(args[1]);
      break;

    case "profile":
      await handleProfileCommand(args.slice(1), flags);
      break;

    case "doctor":
      await cmdDoctor();
      break;

    default:
      printHelp();
      break;
  }
}

async function handleProfileCommand(
  args: string[],
  flags: Record<string, string | boolean>
): Promise<void> {
  const subcommand = args[0];

  switch (subcommand) {
    case "create":
      await cmdProfileCreate(args[1]);
      break;

    case "set":
      const updates: Record<string, unknown> = {};
      if (flags.browser) updates.browser = flags.browser;
      if (flags.executable) updates.executable = flags.executable;
      if (flags.headless !== undefined) updates.headless = flags.headless === true || flags.headless === "true";
      if (flags.headed !== undefined) updates.headless = false;
      if (flags.locale) updates.locale = flags.locale;
      if (flags.timezone) updates.timezone = flags.timezone;
      if (flags.viewport) {
        const [w, h] = (flags.viewport as string).split("x").map(Number);
        updates.viewport = { width: w, height: h };
      }
      await cmdProfileSet(args[1], updates);
      break;

    case "remove":
      await cmdProfileRemove(args[1]);
      break;

    case "list":
      await cmdProfileList();
      break;

    case "show":
      await cmdProfileShow(args[1]);
      break;

    default:
      console.error("Usage: bwsr profile <create|set|remove|list|show> [name] [flags]");
      process.exit(1);
  }
}

function printHelp(): void {
  console.log(`bwsr - Browser daemon manager

Usage: bwsr <command> [options]

Commands:
  start [--profile name] [--session name] [--verbose]
  stop <session> | --all
  list
  cdp [session]
  profile <create|set|remove|list|show> [name] [flags]
  doctor

Examples:
  bwsr profile create default
  bwsr profile set default --browser chromium --headless
  bwsr start
  bwsr cdp
  agent-browser --cdp $(bwsr cdp) snapshot
  bwsr stop --all`);
}

main().catch((err) => {
  console.error(err.message);
  process.exit(1);
});
```

**Step 3: Run type check**

Run: `bunx @typescript/native-preview --noEmit`
Expected: No errors (or fix any that appear)

**Step 4: Test manually**

Run: `bun run dev`
Expected: Shows help output

**Step 5: Commit**

```bash
git add src/cli/commands.ts src/index.ts
git commit -m "feat: add CLI commands and entry point"
```

---

## Task 11: Build Binary

**Step 1: Build the binary**

Run: `bun run build`
Expected: Creates `dist/bwsr` binary

**Step 2: Test binary**

Run: `./dist/bwsr`
Expected: Shows help output

**Step 3: Test full flow**

```bash
./dist/bwsr profile create default
./dist/bwsr profile set default --browser chromium --headless
./dist/bwsr start --verbose
./dist/bwsr list
./dist/bwsr cdp
./dist/bwsr stop --all
```

**Step 4: Commit**

```bash
git add -A
git commit -m "feat: complete bwsr CLI"
```

---

## Task 12: Integration Test

**Files:**
- Create: `tests/integration.test.ts`

**Step 1: Write integration test**

```typescript
// tests/integration.test.ts
import { describe, test, expect, afterAll } from "bun:test";
import { $ } from "bun";

describe("bwsr integration", () => {
  afterAll(async () => {
    // Cleanup
    await $`bun run src/index.ts stop --all`.quiet().nothrow();
  });

  test("profile create and list", async () => {
    await $`bun run src/index.ts profile create test-profile`.quiet();
    const { stdout } = await $`bun run src/index.ts profile list`.quiet();
    expect(stdout.toString()).toContain("test-profile");
    await $`bun run src/index.ts profile remove test-profile`.quiet();
  });

  test("start and stop with default profile", async () => {
    // Ensure default profile exists
    await $`bun run src/index.ts profile create default`.quiet().nothrow();
    await $`bun run src/index.ts profile set default --browser chromium --headless`.quiet();

    // Start
    const { stdout: startOut } = await $`bun run src/index.ts start --session test-int`.quiet();
    expect(startOut.toString().trim()).toBe("test-int");

    // List
    const { stdout: listOut } = await $`bun run src/index.ts list`.quiet();
    expect(listOut.toString()).toContain("test-int");

    // CDP
    const { stdout: cdpOut } = await $`bun run src/index.ts cdp test-int`.quiet();
    const port = parseInt(cdpOut.toString().trim(), 10);
    expect(port).toBeGreaterThan(0);

    // Stop
    await $`bun run src/index.ts stop test-int`.quiet();
  });
});
```

**Step 2: Run integration test**

Run: `bun test tests/integration.test.ts`
Expected: PASS (may need chromium installed)

**Step 3: Commit**

```bash
git add tests/integration.test.ts
git commit -m "test: add integration tests"
```

---

## Summary

After completing all tasks, you will have:

1. **`bwsr` CLI** - precompiled binary for managing browser daemons
2. **Profile system** - YAML configs with browser auto-discovery
3. **IPC architecture** - watchdog + wrappers via Unix sockets
4. **Integration with agent-browser** - `agent-browser --cdp $(bwsr cdp)`

Run `bun run build` to create the final binary at `dist/bwsr`.
